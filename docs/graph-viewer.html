<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>보상작용 연구 네트워크 뷰어 - 옵시디언 스타일</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      margin: 0;
      padding: 0;
      background: radial-gradient(circle at center, #1a1a1a 0%, #0d0d0d 100%);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      overflow: hidden;
      height: 100vh;
    }

    .viewer-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      background:
        radial-gradient(circle at 20% 30%, rgba(100, 200, 255, 0.03) 0%, transparent 50%),
        radial-gradient(circle at 80% 70%, rgba(255, 100, 150, 0.03) 0%, transparent 50%),
        radial-gradient(circle at 50% 50%, rgba(150, 255, 100, 0.02) 0%, transparent 70%);
    }

    .graph-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      cursor: grab;
      overflow: hidden;
    }

    .graph-canvas:active {
      cursor: grabbing;
    }

    .controls-panel {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(30, 30, 30, 0.9);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 12px;
      padding: 1rem;
      color: white;
      backdrop-filter: blur(10px);
      z-index: 1000;
      min-width: 250px;
    }

    .controls-panel h3 {
      margin: 0 0 1rem 0;
      font-size: 1.1rem;
      color: #4a9eff;
    }

    .control-group {
      margin: 1rem 0;
    }

    .control-group label {
      display: block;
      font-size: 0.9rem;
      margin-bottom: 0.5rem;
      color: #ccc;
    }

    .control-group input[type="range"] {
      width: 100%;
      margin: 0.5rem 0;
    }

    .control-group button {
      background: linear-gradient(135deg, #4a9eff 0%, #2563eb 100%);
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      cursor: pointer;
      margin: 0.25rem;
      font-size: 0.8rem;
      transition: all 0.3s ease;
    }

    .control-group button:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(74, 158, 255, 0.4);
    }

    .info-panel {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(30, 30, 30, 0.9);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 12px;
      padding: 1rem;
      color: white;
      backdrop-filter: blur(10px);
      z-index: 1000;
      min-width: 200px;
      max-width: 300px;
    }

    .node {
      position: absolute;
      background: radial-gradient(circle, #4a9eff 0%, #2563eb 100%);
      color: white;
      padding: 0.6rem 1rem;
      border-radius: 25px;
      font-size: 0.7rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      text-align: center;
      min-width: 80px;
      border: 2px solid rgba(255,255,255,0.2);
      box-shadow:
        0 0 15px rgba(74, 158, 255, 0.4),
        inset 0 1px 0 rgba(255,255,255,0.2);
      backdrop-filter: blur(5px);
      z-index: 10;
      user-select: none;
    }

    .node:hover {
      transform: scale(1.2);
      box-shadow:
        0 0 25px rgba(74, 158, 255, 0.8),
        0 0 50px rgba(74, 158, 255, 0.4),
        inset 0 1px 0 rgba(255,255,255,0.3);
      z-index: 100;
    }

    .node.selected {
      transform: scale(1.15);
      box-shadow:
        0 0 30px rgba(255, 255, 255, 0.6),
        0 0 60px rgba(74, 158, 255, 0.8),
        inset 0 1px 0 rgba(255,255,255,0.4);
    }

    .node.center {
      background: radial-gradient(circle, #ff6b6b 0%, #ee5a52 100%);
      font-size: 0.8rem;
      padding: 0.8rem 1.2rem;
      font-weight: 700;
      min-width: 100px;
      box-shadow:
        0 0 20px rgba(255, 107, 107, 0.5),
        inset 0 1px 0 rgba(255,255,255,0.2);
    }

    .node.anatomy {
      background: radial-gradient(circle, #51cf66 0%, #37b24d 100%);
      box-shadow:
        0 0 15px rgba(81, 207, 102, 0.4),
        inset 0 1px 0 rgba(255,255,255,0.2);
    }

    .node.pattern {
      background: radial-gradient(circle, #ffd43b 0%, #fab005 100%);
      box-shadow:
        0 0 15px rgba(255, 212, 59, 0.4),
        inset 0 1px 0 rgba(255,255,255,0.2);
    }

    .node.treatment {
      background: radial-gradient(circle, #da77f2 0%, #ae3ec9 100%);
      box-shadow:
        0 0 15px rgba(218, 119, 242, 0.4),
        inset 0 1px 0 rgba(255,255,255,0.2);
    }

    .connection {
      position: absolute;
      background: linear-gradient(90deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.2) 50%, rgba(255,255,255,0.1) 100%);
      height: 1px;
      transform-origin: left center;
      pointer-events: none;
      z-index: 1;
      opacity: 0.6;
      transition: all 0.3s ease;
    }

    .connection.highlighted {
      background: linear-gradient(90deg, rgba(74, 158, 255, 0.4) 0%, rgba(74, 158, 255, 0.9) 50%, rgba(74, 158, 255, 0.4) 100%);
      height: 2px;
      box-shadow: 0 0 8px rgba(74, 158, 255, 0.6);
      opacity: 1;
    }

    .particles {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 5;
    }

    .particle {
      position: absolute;
      width: 2px;
      height: 2px;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      animation: float 10s infinite linear;
    }

    @keyframes float {
      0% { transform: translateY(100vh) translateX(0); opacity: 0; }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { transform: translateY(-100px) translateX(100px); opacity: 0; }
    }

    .back-button {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: linear-gradient(135deg, #666 0%, #444 100%);
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 25px;
      cursor: pointer;
      text-decoration: none;
      font-weight: 600;
      transition: all 0.3s ease;
      z-index: 1000;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }

    .back-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(0,0,0,0.4);
    }

    .zoom-controls {
      position: fixed;
      bottom: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      z-index: 1000;
    }

    .zoom-button {
      width: 40px;
      height: 40px;
      background: rgba(30, 30, 30, 0.9);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 50%;
      color: white;
      font-size: 1.2rem;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .zoom-button:hover {
      background: rgba(74, 158, 255, 0.8);
      transform: scale(1.1);
    }
  </style>
</head>
<body>
  <div class="viewer-container">
    <div class="controls-panel">
      <h3>🌐 네트워크 컨트롤</h3>

      <div class="control-group">
        <label>물리 시뮬레이션</label>
        <button onclick="togglePhysics()">물리 효과 토글</button>
        <button onclick="resetPositions()">위치 초기화</button>
      </div>

      <div class="control-group">
        <label>연결 강도: <span id="connectionStrength">50</span>%</label>
        <input type="range" id="strengthSlider" min="10" max="100" value="50" oninput="updateConnectionStrength(this.value)">
      </div>

      <div class="control-group">
        <label>애니메이션 속도</label>
        <button onclick="setAnimationSpeed(0.5)">느림</button>
        <button onclick="setAnimationSpeed(1)">보통</button>
        <button onclick="setAnimationSpeed(2)">빠름</button>
      </div>

      <div class="control-group">
        <label>필터</label>
        <button onclick="filterNodes('all')">전체</button>
        <button onclick="filterNodes('anatomy')">해부학</button>
        <button onclick="filterNodes('pattern')">패턴</button>
        <button onclick="filterNodes('treatment')">치료</button>
      </div>
    </div>

    <div class="info-panel">
      <h3>📊 네트워크 정보</h3>
      <div id="networkStats">
        <p>총 노드: <span id="nodeCount">0</span>개</p>
        <p>연결: <span id="connectionCount">0</span>개</p>
        <p>클러스터: <span id="clusterCount">5</span>개</p>
      </div>
      <div id="selectedNodeInfo" style="margin-top: 1rem; display: none;">
        <h4>선택된 노드</h4>
        <p id="nodeTitle"></p>
        <p id="nodeType"></p>
        <p id="nodeConnections"></p>
      </div>
    </div>

    <div class="graph-canvas" id="graphCanvas">
      <div class="particles" id="particles"></div>

      <!-- 노드들 - 더 많고 복잡한 네트워크 -->
      <!-- 중심 노드 -->
      <div class="node center" style="top: 40%; left: 45%;" data-type="hub" data-title="보상작용 연구 허브">
        보상작용<br>연구 허브
      </div>

      <!-- 해부학 클러스터 -->
      <div class="node anatomy" style="top: 15%; left: 20%;" data-type="anatomy" data-title="Gluteus Medius">
        Gluteus<br>Medius
      </div>
      <div class="node anatomy" style="top: 25%; left: 15%;" data-type="anatomy" data-title="TFL">
        TFL
      </div>
      <div class="node anatomy" style="top: 35%; left: 10%;" data-type="anatomy" data-title="Hip Joint">
        Hip Joint
      </div>
      <div class="node anatomy" style="top: 10%; left: 30%;" data-type="anatomy" data-title="Quadratus Lumborum">
        Quadratus<br>Lumborum
      </div>
      <div class="node anatomy" style="top: 20%; left: 35%;" data-type="anatomy" data-title="IT Band">
        IT Band
      </div>
      <div class="node anatomy" style="top: 30%; left: 25%;" data-type="anatomy" data-title="Core Muscles">
        Core<br>Muscles
      </div>
      <div class="node anatomy" style="top: 5%; left: 40%;" data-type="anatomy" data-title="Piriformis">
        Piriformis
      </div>

      <!-- 패턴 클러스터 -->
      <div class="node pattern" style="top: 10%; left: 55%;" data-type="pattern" data-title="Hip Drop Pattern">
        Hip Drop<br>Pattern
      </div>
      <div class="node pattern" style="top: 20%; left: 65%;" data-type="pattern" data-title="Trendelenburg Sign">
        Trendelenburg<br>Sign
      </div>
      <div class="node pattern" style="top: 15%; left: 75%;" data-type="pattern" data-title="Lateral Shift">
        Lateral<br>Shift
      </div>
      <div class="node pattern" style="top: 5%; left: 70%;" data-type="pattern" data-title="Knee Valgus">
        Knee<br>Valgus
      </div>
      <div class="node pattern" style="top: 25%; left: 80%;" data-type="pattern" data-title="IT Band Syndrome">
        IT Band<br>Syndrome
      </div>
      <div class="node pattern" style="top: 30%; left: 70%;" data-type="pattern" data-title="Ankle Compensation">
        Ankle<br>Compensation
      </div>

      <!-- 평가 클러스터 -->
      <div class="node" style="top: 60%; left: 15%;" data-type="assessment" data-title="Trendelenburg Test">
        Trendelenburg<br>Test
      </div>
      <div class="node" style="top: 65%; left: 25%;" data-type="assessment" data-title="Single Leg Squat">
        Single Leg<br>Squat Test
      </div>
      <div class="node" style="top: 70%; left: 35%;" data-type="assessment" data-title="5WHY Analysis">
        5WHY<br>Analysis
      </div>
      <div class="node" style="top: 55%; left: 30%;" data-type="assessment" data-title="Gait Analysis">
        Gait<br>Analysis
      </div>
      <div class="node" style="top: 75%; left: 20%;" data-type="assessment" data-title="EMG Analysis">
        EMG<br>Analysis
      </div>
      <div class="node" style="top: 50%; left: 20%;" data-type="assessment" data-title="Movement Screen">
        Movement<br>Screen
      </div>

      <!-- 치료 클러스터 -->
      <div class="node treatment" style="top: 55%; left: 65%;" data-type="treatment" data-title="Progressive Loading">
        Progressive<br>Loading
      </div>
      <div class="node treatment" style="top: 65%; left: 75%;" data-type="treatment" data-title="Manual Therapy">
        Manual<br>Therapy
      </div>
      <div class="node treatment" style="top: 70%; left: 65%;" data-type="treatment" data-title="Exercise Protocol">
        Exercise<br>Protocol
      </div>
      <div class="node treatment" style="top: 60%; left: 80%;" data-type="treatment" data-title="Strengthening">
        Strengthening<br>Protocol
      </div>
      <div class="node treatment" style="top: 75%; left: 80%;" data-type="treatment" data-title="Motor Control">
        Motor Control<br>Training
      </div>
      <div class="node treatment" style="top: 50%; left: 75%;" data-type="treatment" data-title="Dry Needling">
        Dry<br>Needling
      </div>
    </div>

    <div class="zoom-controls">
      <button class="zoom-button" onclick="zoomIn()">+</button>
      <button class="zoom-button" onclick="zoomOut()">−</button>
      <button class="zoom-button" onclick="resetZoom()">⌂</button>
    </div>

    <a href="./index.html" class="back-button">← 위키로 돌아가기</a>
  </div>

  <script>
    let isDragging = false;
    let dragNode = null;
    let physicsEnabled = true;
    let animationSpeed = 1;
    let zoomLevel = 1;
    let panX = 0;
    let panY = 0;
    let selectedNode = null;

    // 초기화
    document.addEventListener('DOMContentLoaded', function() {
      createParticles();
      setupNodeInteractions();
      drawConnections();
      updateStats();
      startAnimation();
    });

    // 파티클 생성
    function createParticles() {
      const particlesContainer = document.getElementById('particles');
      for (let i = 0; i < 50; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        particle.style.left = Math.random() * 100 + '%';
        particle.style.animationDelay = Math.random() * 10 + 's';
        particle.style.animationDuration = (8 + Math.random() * 4) + 's';
        particlesContainer.appendChild(particle);
      }
    }

    // 노드 상호작용 설정
    function setupNodeInteractions() {
      const nodes = document.querySelectorAll('.node');

      nodes.forEach(node => {
        // 클릭 이벤트
        node.addEventListener('click', function(e) {
          e.stopPropagation();
          selectNode(this);
        });

        // 드래그 이벤트
        node.addEventListener('mousedown', function(e) {
          e.preventDefault();
          isDragging = true;
          dragNode = this;
          document.addEventListener('mousemove', dragMove);
          document.addEventListener('mouseup', dragEnd);
        });

        // 호버 이벤트
        node.addEventListener('mouseenter', function() {
          highlightConnections(this);
        });

        node.addEventListener('mouseleave', function() {
          unhighlightConnections();
        });
      });

      // 캔버스 클릭 시 선택 해제
      document.getElementById('graphCanvas').addEventListener('click', function() {
        if (selectedNode) {
          selectedNode.classList.remove('selected');
          selectedNode = null;
          document.getElementById('selectedNodeInfo').style.display = 'none';
        }
      });
    }

    // 노드 선택
    function selectNode(node) {
      if (selectedNode) {
        selectedNode.classList.remove('selected');
      }

      selectedNode = node;
      node.classList.add('selected');

      // 정보 패널 업데이트
      const infoPanel = document.getElementById('selectedNodeInfo');
      document.getElementById('nodeTitle').textContent = node.dataset.title;
      document.getElementById('nodeType').textContent = '유형: ' + node.dataset.type;

      const connections = getNodeConnections(node);
      document.getElementById('nodeConnections').textContent = `연결: ${connections}개`;

      infoPanel.style.display = 'block';
    }

    // 드래그 이동
    function dragMove(e) {
      if (!isDragging || !dragNode) return;

      const rect = document.getElementById('graphCanvas').getBoundingClientRect();
      const x = ((e.clientX - rect.left) / rect.width) * 100;
      const y = ((e.clientY - rect.top) / rect.height) * 100;

      dragNode.style.left = Math.max(0, Math.min(95, x)) + '%';
      dragNode.style.top = Math.max(0, Math.min(95, y)) + '%';

      drawConnections();
    }

    // 드래그 종료
    function dragEnd() {
      isDragging = false;
      dragNode = null;
      document.removeEventListener('mousemove', dragMove);
      document.removeEventListener('mouseup', dragEnd);
    }

    // 연결선 그리기
    function drawConnections() {
      const canvas = document.getElementById('graphCanvas');
      const centerNode = document.querySelector('.node.center');
      const allNodes = document.querySelectorAll('.node:not(.center)');

      // 기존 연결선 제거
      canvas.querySelectorAll('.connection').forEach(conn => conn.remove());

      if (!centerNode) return;

      const centerRect = centerNode.getBoundingClientRect();
      const canvasRect = canvas.getBoundingClientRect();
      const centerX = centerRect.left - canvasRect.left + centerRect.width / 2;
      const centerY = centerRect.top - canvasRect.top + centerRect.height / 2;

      // 중심 노드와 모든 노드 연결
      allNodes.forEach(node => {
        const nodeRect = node.getBoundingClientRect();
        const nodeX = nodeRect.left - canvasRect.left + nodeRect.width / 2;
        const nodeY = nodeRect.top - canvasRect.top + nodeRect.height / 2;

        createConnection(centerX, centerY, nodeX, nodeY, canvas);
      });

      // 같은 타입 노드들 간 연결
      const nodesByType = {};
      allNodes.forEach(node => {
        const type = node.dataset.type;
        if (!nodesByType[type]) nodesByType[type] = [];
        nodesByType[type].push(node);
      });

      Object.values(nodesByType).forEach(typeNodes => {
        if (typeNodes.length > 1) {
          for (let i = 0; i < typeNodes.length - 1; i++) {
            const node1 = typeNodes[i];
            const node2 = typeNodes[i + 1];

            const rect1 = node1.getBoundingClientRect();
            const rect2 = node2.getBoundingClientRect();

            const x1 = rect1.left - canvasRect.left + rect1.width / 2;
            const y1 = rect1.top - canvasRect.top + rect1.height / 2;
            const x2 = rect2.left - canvasRect.left + rect2.width / 2;
            const y2 = rect2.top - canvasRect.top + rect2.height / 2;

            createConnection(x1, y1, x2, y2, canvas, 'type-connection');
          }
        }
      });
    }

    // 연결선 생성
    function createConnection(x1, y1, x2, y2, container, className = 'connection') {
      const connection = document.createElement('div');
      connection.className = className;

      const deltaX = x2 - x1;
      const deltaY = y2 - y1;
      const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      const angle = Math.atan2(deltaY, deltaX) * (180 / Math.PI);

      connection.style.left = x1 + 'px';
      connection.style.top = y1 + 'px';
      connection.style.width = distance + 'px';
      connection.style.transform = `rotate(${angle}deg)`;

      container.appendChild(connection);
    }

    // 연결 하이라이트
    function highlightConnections(node) {
      const connections = document.querySelectorAll('.connection');
      connections.forEach(conn => conn.classList.add('highlighted'));
    }

    function unhighlightConnections() {
      const connections = document.querySelectorAll('.connection');
      connections.forEach(conn => conn.classList.remove('highlighted'));
    }

    // 통계 업데이트
    function updateStats() {
      const nodeCount = document.querySelectorAll('.node').length;
      const connectionCount = document.querySelectorAll('.connection').length;

      document.getElementById('nodeCount').textContent = nodeCount;
      document.getElementById('connectionCount').textContent = connectionCount;
    }

    // 노드 연결 수 계산
    function getNodeConnections(node) {
      // 간단한 계산 - 실제로는 더 복잡한 로직 필요
      return Math.floor(Math.random() * 8) + 2;
    }

    // 컨트롤 함수들
    function togglePhysics() {
      physicsEnabled = !physicsEnabled;
      console.log('Physics:', physicsEnabled ? 'enabled' : 'disabled');
    }

    function resetPositions() {
      // 위치 초기화 로직
      location.reload();
    }

    function updateConnectionStrength(value) {
      document.getElementById('connectionStrength').textContent = value;
      const connections = document.querySelectorAll('.connection');
      connections.forEach(conn => {
        conn.style.opacity = value / 100;
      });
    }

    function setAnimationSpeed(speed) {
      animationSpeed = speed;
      document.documentElement.style.setProperty('--animation-speed', speed);
    }

    function filterNodes(type) {
      const nodes = document.querySelectorAll('.node');
      nodes.forEach(node => {
        if (type === 'all' || node.dataset.type === type || node.classList.contains('center')) {
          node.style.display = 'block';
        } else {
          node.style.display = 'none';
        }
      });
      setTimeout(drawConnections, 100);
    }

    function zoomIn() {
      zoomLevel = Math.min(zoomLevel * 1.2, 3);
      applyZoom();
    }

    function zoomOut() {
      zoomLevel = Math.max(zoomLevel / 1.2, 0.3);
      applyZoom();
    }

    function resetZoom() {
      zoomLevel = 1;
      panX = 0;
      panY = 0;
      applyZoom();
    }

    function applyZoom() {
      const canvas = document.getElementById('graphCanvas');
      canvas.style.transform = `scale(${zoomLevel}) translate(${panX}px, ${panY}px)`;
    }

    // 애니메이션 루프
    function startAnimation() {
      function animate() {
        if (physicsEnabled) {
          // 물리 시뮬레이션 로직 (간단한 버전)
          updatePhysics();
        }
        requestAnimationFrame(animate);
      }
      animate();
    }

    function updatePhysics() {
      // 간단한 물리 시뮬레이션
      // 실제로는 더 복잡한 force-directed graph 알고리즘 사용
    }

    // 창 크기 변경 시 연결선 다시 그리기
    window.addEventListener('resize', () => {
      setTimeout(drawConnections, 100);
    });
  </script>
</body>
</html>